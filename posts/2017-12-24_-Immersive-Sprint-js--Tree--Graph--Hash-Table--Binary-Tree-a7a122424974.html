<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>[Immersive_Sprint.js] Tree, Graph, Hash Table, Binary Tree</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">[Immersive_Sprint.js] Tree, Graph, Hash Table, Binary Tree</h1>
</header>
<section data-field="subtitle" class="p-summary">
Code States의 Immersive Sprint를 수강하고 있다.
</section>
<section data-field="body" class="e-content">
<section name="5c58" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="116e" id="116e" class="graf graf--h3 graf--leading graf--title">[Immersive_Sprint.js] Tree, Graph, Hash Table, Binary Tree</h3><p name="6dab" id="6dab" class="graf graf--p graf-after--h3"><a href="http://www.codestates.com" data-href="http://www.codestates.com" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Code States</a>의 Immersive Sprint를 수강하고 있다.</p><p name="a4e4" id="a4e4" class="graf graf--p graf-after--p">1주차에 진행한 내용은 <strong class="markup--strong markup--p-strong">자료 구조 </strong>이다</p><ol class="postList"><li name="2db5" id="2db5" class="graf graf--li graf-after--p">Stack &amp; Queue</li><li name="a3d1" id="a3d1" class="graf graf--li graf-after--li">Linked List</li><li name="52e8" id="52e8" class="graf graf--li graf-after--li">Tree</li><li name="d381" id="d381" class="graf graf--li graf-after--li">Graph</li><li name="db94" id="db94" class="graf graf--li graf-after--li">Hash Table</li><li name="3bce" id="3bce" class="graf graf--li graf-after--li">Binary Tree</li></ol><p name="3989" id="3989" class="graf graf--p graf-after--li">위처럼 목차대로 1주차를 진행하였다.</p><p name="ae65" id="ae65" class="graf graf--p graf-after--p">Graph부터 Binary Tree까지 정리하려고 봤더니,, 배웠던 부분도 적지 않은 부분이지만 실제로 기본이 되는 내용만 배운지라 새로 또 공부해서 포스팅을 하려니 부담이 된다..</p><p name="3b2c" id="3b2c" class="graf graf--p graf-after--p">그래서 나머지는 어느정도 묶어서 포스팅을 해야겠다.</p><p name="41f7" id="41f7" class="graf graf--p graf-after--p">먼저…</p><h3 name="0fd0" id="0fd0" class="graf graf--h3 graf-after--p">Tree</h3><p name="4dfd" id="4dfd" class="graf graf--p graf-after--h3">트리구조는 Graph의 일종이다.</p><p name="8d62" id="8d62" class="graf graf--p graf-after--p">트리의 종류에도 여러 종류가 있지만, 여기서는 단순히 Tree에 대해서만 이야기하고 아래에서 Binary Tree에 대해서도 간단히 설명하고 구현한다.</p><p name="d96e" id="d96e" class="graf graf--p graf-after--p">Tree는 자신의 값 (value)와 자식노드(children) 의 값을 가진다.</p><p name="df88" id="df88" class="graf graf--p graf-after--p">그리고 child 추가, searching에 대한 메소드를 갖는다. (단순하다.ㅎㅎ 삭제가 있었다면.. 정말 어려웠을거 같다. 나중엔 구현해봐야지)</p><p name="80f9" id="80f9" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">newTree</code> (type : object)</p><ul class="postList"><li name="e3c9" id="e3c9" class="graf graf--li graf-after--p">Tree 생성자를 통해 새로운 객체를 만들었을 경우 node의 값 및 각종 필요한 메소드들을 담고 있다.</li></ul><p name="11a1" id="11a1" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">newTree.value</code> (type : number)</p><ul class="postList"><li name="d9d9" id="d9d9" class="graf graf--li graf-after--p">노드 생성시 노드의 값을 저장한다.</li></ul><p name="bf61" id="bf61" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">newTree.children</code> (type : array)</p><ul class="postList"><li name="8bc1" id="8bc1" class="graf graf--li graf-after--p">자식 노드의 연결 관계를 명시한다.</li><li name="407b" id="407b" class="graf graf--li graf-after--li">여기서는 input된 순서대로 배열에 담았다.</li></ul><p name="4033" id="4033" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">newTree.addChildren</code></p><ul class="postList"><li name="e953" id="e953" class="graf graf--li graf-after--p">노드를 추가하기 위한 메소드</li></ul><p name="bc0c" id="bc0c" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">newTree.contains</code></p><ul class="postList"><li name="28ae" id="28ae" class="graf graf--li graf-after--p">특정한 value 값을 가진 node가 현재 tree에 있는지 확인하기 위한 메소드</li><li name="6f4b" id="6f4b" class="graf graf--li graf-after--li">트리구조에서 특정 값을 얻어오기위해서는 마지막 childNode가 null 일때까지 돌린 후 재귀로 다시 부모 node 혹은 root로 돌아와야 한다.</li><li name="60fe" id="60fe" class="graf graf--li graf-after--li">그래서재귀를 돌렸다</li></ul><p name="ca99" id="ca99" class="graf graf--p graf-after--li">내용이 너무 단순해서.. (물론 코드를 찾아 나가는데에는 오래걸렸지만 ㅠㅠ) 바로 코드를 추가한다.</p><pre name="21b8" id="21b8" class="graf graf--pre graf-after--p">var Tree = function(value) {<br>  var newTree={};<br>  newTree.value = value;<br>  newTree.children = [];<br>  _.extend ( newTree, treeMethods);<br>  return newTree;<br>};</pre><pre name="efcf" id="efcf" class="graf graf--pre graf-after--pre">var treeMethods = {};</pre><pre name="3420" id="3420" class="graf graf--pre graf-after--pre">treeMethods.addChild = function(value) {<br>  var tree = Tree(value);<br>  this.children.push(tree);<br>  return tree;<br>};</pre><pre name="074f" id="074f" class="graf graf--pre graf-after--pre graf--trailing">treeMethods.contains = function(target) {<br>  var flag = false;<br>  function recurForTarget (current){<br>    for (var i = 0; i &lt; current.length; i++) {<br>      if ( current[i].children.length !==0 ){<br>        recurForTarget ( current[i].children );<br>      }<br>      else {<br>        if ( current[i].value === target ){<br>          flag = true;<br>        }<br>      }<br>    }<br>    return flag;<br>  }<br>  return recurForTarget(this.children);<br>};</pre></div></div></section><section name="268b" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5892" id="5892" class="graf graf--h3 graf--leading">Graph</h3><p name="7a42" id="7a42" class="graf graf--p graf-after--h3">자료 구조에서 그래프는 방향을 가진 그래프 ( directed graph ) 와 무방향 그래프 ( undirected graph )로 나뉜다.</p><p name="99de" id="99de" class="graf graf--p graf-after--p">내가 구현한 그래프는 방향이 없는 그래프이다. 나는 엄청나게 단순하게 구현했는데.. 더 좋은 방법들은 충분히 많을 것 같다.</p><p name="d01a" id="d01a" class="graf graf--p graf-after--p">아래와 같은 변수와 메소드를 통해 구현을 하였다.</p><p name="35ab" id="35ab" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">node</code> (type : object)</p><ul class="postList"><li name="0c91" id="0c91" class="graf graf--li graf-after--p">node의 값들을 저장하기 위한 변수 ( 배열로 해도되나 ? 왜 객체로 했는지는 까먹었다. )</li><li name="2a96" id="2a96" class="graf graf--li graf-after--li">새로 1이라는 값을 가진 노드를 추가하게 되면 아래와 같이 추가가되게된다.</li><li name="c223" id="c223" class="graf graf--li graf-after--li">node = {1: ‘1’};</li></ul><p name="531e" id="531e" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">edge</code> (type : object)</p><ul class="postList"><li name="e071" id="e071" class="graf graf--li graf-after--p">node들간 연결을 표현하기 위한 변수</li><li name="4c5a" id="4c5a" class="graf graf--li graf-after--li">1이라는 value를 가진 노드와 3이라는 value를 가진 노드가 연결되게 되면 아래와 같이 표현된다.</li><li name="3b42" id="3b42" class="graf graf--li graf-after--li">edge = {1 : ‘3’};</li><li name="df2e" id="df2e" class="graf graf--li graf-after--li">undirected graph의 형태이기 때문에 1이 key가 되어도 3이 key가 되어도 상관없다.</li></ul><p name="54bf" id="54bf" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">addNode</code></p><ul class="postList"><li name="e9f8" id="e9f8" class="graf graf--li graf-after--p">노드를 추가하기 위한 메소드</li><li name="898c" id="898c" class="graf graf--li graf-after--li">단순히 node object에 추가된다.</li></ul><p name="b3b8" id="b3b8" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">contains</code></p><ul class="postList"><li name="4298" id="4298" class="graf graf--li graf-after--p">특정 value 값이 node에 포함되어있는지 확인하기 위한 메소드</li><li name="a944" id="a944" class="graf graf--li graf-after--li">node 변수의 값중 찾고자하는 value값이 포함되어 있으면 true return</li></ul><p name="7edb" id="7edb" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">removeNode</code></p><ul class="postList"><li name="0b49" id="0b49" class="graf graf--li graf-after--p">특정 value 값을 node에서 삭제하기 위한 메소드</li><li name="0bdb" id="0bdb" class="graf graf--li graf-after--li">삭제된 node를 return 한다.</li></ul><p name="f2df" id="f2df" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">hasEdge</code></p><ul class="postList"><li name="c58f" id="c58f" class="graf graf--li graf-after--p">특정 값을 가진 두개의 node가 연결 되어 있는지 확인하는 메소드</li></ul><p name="1960" id="1960" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">addEdge</code></p><ul class="postList"><li name="706a" id="706a" class="graf graf--li graf-after--p">특정 값 두개를 연결 하는 메소드</li></ul><p name="6d0d" id="6d0d" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">removeEdge</code></p><ul class="postList"><li name="f56f" id="f56f" class="graf graf--li graf-after--p">특정 노드간 연결되어 있는 edge를 삭제 하는 메소드</li></ul><p name="2c71" id="2c71" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">forEachNode</code></p><ul class="postList"><li name="4cdf" id="4cdf" class="graf graf--li graf-after--p">특정 노드의 값을 지정하였을 때 현재 그래프에 있는 모든 노드와 연결 시키기 위한 메소드</li></ul><p name="04e4" id="04e4" class="graf graf--p graf-after--li">소스코드를 바로 보자</p><pre name="7683" id="7683" class="graf graf--pre graf-after--p">// Instantiate a new graph<br>var Graph = function() {<br>  this.node = {};<br>  this.edge = {};<br>};</pre><pre name="109b" id="109b" class="graf graf--pre graf-after--pre">// Add a node to the graph, passing in the node&#39;s value.<br>Graph.prototype.addNode = function(node) {<br>  this.node[node] = node;<br>};</pre><pre name="9aec" id="9aec" class="graf graf--pre graf-after--pre">// Return a boolean value indicating if the value passed to contains is represented in the graph.<br>Graph.prototype.contains = function(node) {<br>  for ( var key in this.node){<br>    if ( this.node[key] === node ) return true;<br>  }<br>  return false;<br>};</pre><pre name="0fdd" id="0fdd" class="graf graf--pre graf-after--pre">// Removes a node from the graph.<br>Graph.prototype.removeNode = function(node) {<br>  for ( var key in this.edge ) {<br>    if ( key == node.toString() ) {<br>      this.removeEdge(node, this.edge[key]);<br>    }<br>    else if ( this.edge[key] === node ){<br>      this.removeEdge(key, node);<br>    }<br>  }<br>  delete this.node[node];<br>};</pre><pre name="6978" id="6978" class="graf graf--pre graf-after--pre">// Returns a boolean indicating whether two specified nodes are connected.  Pass in the values contained in each of the two nodes.<br>Graph.prototype.hasEdge = function(fromNode, toNode) {<br>  for ( var key in this.edge ) {<br>    if ( (key == fromNode.toString()) &amp;&amp; (this.edge[key] === toNode) || (key === toNode.toString() &amp;&amp; this.edge[key] === fromNode) ){<br>      return true;<br>    }<br>  }<br>  return false;<br>};</pre><pre name="1bcb" id="1bcb" class="graf graf--pre graf-after--pre">// Connects two nodes in a graph by adding an edge between them.<br>Graph.prototype.addEdge = function(fromNode, toNode) {<br>  this.edge[fromNode] = toNode;<br>};</pre><pre name="28b0" id="28b0" class="graf graf--pre graf-after--pre">// Remove an edge between any two specified (by value) nodes.<br>Graph.prototype.removeEdge = function(fromNode, toNode) {<br>  for ( var key in this.edge ) {<br>    if ( (key == fromNode.toString() &amp;&amp; this.edge[key] === toNode) || (key === toNode.toString() &amp;&amp; this.edge[key] === fromNode) ){<br>      delete this.edge[key];<br>    }<br>  }<br>};</pre><pre name="1323" id="1323" class="graf graf--pre graf-after--pre">// Pass in a callback which will be executed on each node of the graph.<br>Graph.prototype.forEachNode = function(cb) {<br>  for ( var key in this.node ){<br>    cb(key);<br>  }</pre><pre name="8012" id="8012" class="graf graf--pre graf-after--pre graf--trailing">var cb = function(item) {<br>      graph.addEdge(item, 5);<br>};};</pre></div></div></section><section name="8508" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="f6fa" id="f6fa" class="graf graf--h3 graf--leading"><strong class="markup--strong markup--h3-strong">Hash Table</strong></h3><p name="230c" id="230c" class="graf graf--p graf-after--h3">hash는 아직 심화문제를 풀지는 못했다. 작성된 것 까지만 일단 코드 공유</p><p name="39b2" id="39b2" class="graf graf--p graf-after--p">시간 복잡도는 일반적으로 O(1) 이다.</p><pre name="1742" id="1742" class="graf graf--pre graf-after--p">var HashTable = function() {<br>  this._limit = 8;<br>  this._storage = LimitedArray(this._limit);<br>};</pre><pre name="e1c7" id="e1c7" class="graf graf--pre graf-after--pre">HashTable.prototype.insert = function(k, v) {<br>  var index = getIndexBelowMaxForKey(k, this._limit);<br>  var keyValuePair = { [k] : v };<br>  var obj = this._storage.get( index ) || {} ;<br>  obj[k] = v;<br>  this._storage.set(index,obj);<br>};</pre><pre name="198b" id="198b" class="graf graf--pre graf-after--pre">HashTable.prototype.retrieve = function(k) {<br>  var index = getIndexBelowMaxForKey(k, this._limit);<br>  return this._storage.get(index)[k];<br>};</pre><pre name="f5f2" id="f5f2" class="graf graf--pre graf-after--pre graf--trailing">HashTable.prototype.remove = function(k) {<br>  var index = getIndexBelowMaxForKey(k, this._limit);<br>  delete this._storage.get(index)[k];<br>};</pre></div></div></section><section name="8c33" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="b378" id="b378" class="graf graf--p graf--leading">마지막으로..</p><h3 name="d8ad" id="d8ad" class="graf graf--h3 graf-after--p">Binary Search Tree</h3><p name="e6c1" id="e6c1" class="graf graf--p graf-after--h3">1개 또는 2개의 자식만을 가지는 Tree를 말한다.</p><p name="6a07" id="6a07" class="graf graf--p graf-after--p">최악의 경우 O(n)의 시간 복잡도를 가지지만 balancing 과정을 통해 O(logN)의 복잡도를 가질 수 있다.</p><pre name="7808" id="7808" class="graf graf--pre graf-after--p">var BinarySearchTree = function(value) {<br>    var nTree = Object.create(tMethods);<br>    nTree.value = value;<br>    nTree.left = null;<br>    nTree.right = null;<br>    return nTree;<br>};</pre><pre name="e79a" id="e79a" class="graf graf--pre graf-after--pre">var tMethods = {};</pre><pre name="4938" id="4938" class="graf graf--pre graf-after--pre">tMethods.insert = function (value){<br>    var subTree = new BinarySearchTree(value);</pre><pre name="e0f7" id="e0f7" class="graf graf--pre graf-after--pre">function RecuForInsert ( currentNode ) {<br>        if ( subTree.value &lt;= currentNode.value ){<br>            if ( currentNode.left ) {<br>                RecuForInsert(currentNode.left);<br>            }<br>            else {<br>                currentNode.left = subTree;<br>            }<br>        }<br>        else {<br>            if ( currentNode.right ) {<br>                RecuForInsert(currentNode.right);<br>            }<br>            else {<br>                currentNode.right = subTree;<br>            } <br>        }<br>    }<br>   return RecuForInsert ( this );<br>}</pre><pre name="8d59" id="8d59" class="graf graf--pre graf-after--pre">tMethods.contains = function ( value ) {<br>    var flag = false;<br>    function RecuForContains(currentNode) {<br>        if ( value === currentNode.value ){<br>            flag = true;<br>        }<br>        else if ( value &lt;= currentNode.value &amp;&amp; !flag) {<br>            if ( currentNode.left ) {<br>                RecuForContains(currentNode.left);<br>            }<br>        }<br>        else if ( value &gt; currentNode.value &amp;&amp; !flag) {<br>            if ( currentNode.right ) {<br>                RecuForContains(currentNode.right);<br>            }<br>            <br>        }<br>        return flag;<br>    }<br>    return RecuForContains ( this );<br>}<br>tMethods.depthFirstLog = function ( fn ) { // function</pre><pre name="8941" id="8941" class="graf graf--pre graf-after--pre graf--trailing">function RecuForPush (current){<br>        if ( current.value ){<br>            fn(current.value);<br>            if ( current.left ){<br>                RecuForPush(current.left);<br>            }<br>            else if ( current.right ){<br>                RecuForPush(current.right);<br>            }<br>        }<br>        <br>    };<br>    return RecuForPush(this);<br>}</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lyhlg0201" class="p-author h-card">이용현</a> on <a href="https://medium.com/p/a7a122424974"><time class="dt-published" datetime="2017-12-24T09:29:15.520Z">December 24, 2017</time></a>.</p><p><a href="https://medium.com/@lyhlg0201/immersive-sprint-js-tree-graph-hash-table-binary-tree-a7a122424974" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 5, 2020.</p></footer></article></body></html>