<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>[Immersive_Sprint.js] Stack &amp; Queue</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">[Immersive_Sprint.js] Stack &amp; Queue</h1>
</header>
<section data-field="subtitle" class="p-summary">
Immersive Sprint 1 : Object-Oriented Programming
</section>
<section data-field="body" class="e-content">
<section name="9866" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="29d6" id="29d6" class="graf graf--h3 graf--leading graf--title">[Immersive_Sprint.js] Stack &amp; Queue</h3><blockquote name="1d80" id="1d80" class="graf graf--pullquote graf-after--h3">Immersive Sprint 1 : Object-Oriented Programming</blockquote><h3 name="c154" id="c154" class="graf graf--h3 graf-after--pullquote">Stack</h3><blockquote name="6f17" id="6f17" class="graf graf--blockquote graf-after--h3">자료들을 차례대로 넣고(push) 꺼낼 때는 가장 마지막에 쌓여진 자료부터 빼낸다(pop).</blockquote><p name="8a32" id="8a32" class="graf graf--p graf-after--blockquote">배열에서 array.push()와 array.pop() 메소드를 사용할 때와 동일하다고 볼 수 있다.</p><p name="5492" id="5492" class="graf graf--p graf-after--p">Stack의 구조를 “LIFO ( Last In First Out )” 후입 선출이라고도 부른다.</p><figure name="28a5" id="28a5" class="graf graf--figure graf-after--p graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 450px; max-height: 326px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 72.39999999999999%;"></div><img class="graf-image" data-image-id="1*Bh6Vm9QFj7PfCRw1_0r8Tw.png" data-width="450" data-height="326" src="https://cdn-images-1.medium.com/max/800/1*Bh6Vm9QFj7PfCRw1_0r8Tw.png"></div><figcaption class="imageCaption">Stack</figcaption></figure></div></div></section><section name="a650" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="e223" id="e223" class="graf graf--p graf--leading">javascript 언어를 통해 Stack을 구현해 보자.</p><p name="f3f0" id="f3f0" class="graf graf--p graf-after--p">아래와 같은 변수와 메소드가 필요하다.</p><p name="314f" id="314f" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">someInstance</code> (type: object)</p><ul class="postList"><li name="9ab3" id="9ab3" class="graf graf--li graf-after--p">Stack method를 담을 객체</li></ul><p name="d835" id="d835" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">storage</code> (type: object)</p><ul class="postList"><li name="5527" id="5527" class="graf graf--li graf-after--p">배열을 흉내내기 위한 객체</li><li name="61af" id="61af" class="graf graf--li graf-after--li">0번째 index에 ‘yonghyun’을 담게되면 storage객체에는 아래와 같이 담기게 할것이다.</li><li name="5687" id="5687" class="graf graf--li graf-after--li">storage = { 0 : ‘yonghyun’ };</li></ul><p name="58b1" id="58b1" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">count</code> (type: number)</p><ul class="postList"><li name="a688" id="a688" class="graf graf--li graf-after--p">값을 <code class="markup--code markup--li-code">pop()</code> 할때 마지막에 <code class="markup--code markup--li-code">push()</code> 되어진 index를 알아내기 위한 변수</li><li name="be9e" id="be9e" class="graf graf--li graf-after--li">size값을 알아올 때에도 <code class="markup--code markup--li-code">count</code> 값을 return 하여 얻어 낼 수 있다.</li></ul><p name="b7a3" id="b7a3" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">push()</code></p><ul class="postList"><li name="637e" id="637e" class="graf graf--li graf-after--p">데이터를 담기 위한 메소드</li></ul><p name="d7a4" id="d7a4" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">pop()</code></p><ul class="postList"><li name="e4e9" id="e4e9" class="graf graf--li graf-after--p">데이터를 빼기 위한 메소드</li></ul><p name="1bad" id="1bad" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">size()</code></p><ul class="postList"><li name="4796" id="4796" class="graf graf--li graf-after--p">담긴 데이터의 length를 구하기 위한 메소드</li></ul><p name="ce19" id="ce19" class="graf graf--p graf-after--li">아래처럼 동작 하도록 구현을 하면 될 것 같다.</p><figure name="c80c" id="c80c" class="graf graf--figure graf-after--p graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 665px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 95%;"></div><img class="graf-image" data-image-id="1*qieI8DuFTy-tXEKdVkawLw.png" data-width="1444" data-height="1372" src="https://cdn-images-1.medium.com/max/800/1*qieI8DuFTy-tXEKdVkawLw.png"></div><figcaption class="imageCaption">Stack</figcaption></figure></div></div></section><section name="d876" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="1bea" id="1bea" class="graf graf--p graf--leading">위와 같이 동작하도록 소스코드를 작성하면 아래와 같다.</p><pre name="e9d5" id="e9d5" class="graf graf--pre graf-after--p">var Stack = function() {<br>  var someInstance = {};<br>  var storage = {};<br>  var count = 0;</pre><pre name="3764" id="3764" class="graf graf--pre graf-after--pre">someInstance.push = function(value) {<br>  storage[count]=value;<br>  count++;<br>};</pre><pre name="0370" id="0370" class="graf graf--pre graf-after--pre">someInstance.pop = function() {<br>  if ( count &lt; 1 ){<br>    return ;<br>  }<br>  var popedValue = storage[count-1];<br>  delete storage[count-1];<br>  count--;<br>  return popedValue;<br>};</pre><pre name="7180" id="7180" class="graf graf--pre graf-after--pre">someInstance.size = function() {<br>  return count;<br>};</pre><pre name="be4b" id="be4b" class="graf graf--pre graf-after--pre">return someInstance;</pre><pre name="e7fd" id="e7fd" class="graf graf--pre graf-after--pre">};</pre><h3 name="9ae9" id="9ae9" class="graf graf--h3 graf-after--pre">Queue</h3><blockquote name="d954" id="d954" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">자료를 집어 넣고 (Enqueue) 빼낼 때는 먼저 들어간 값부터 빼낸다(dequeue).</em></blockquote><p name="59c8" id="59c8" class="graf graf--p graf-after--blockquote">여기서 주의해야할 점은 dequeue를 할 경우 각 배열의 index 값이 변한다는 것이다.</p><p name="317b" id="317b" class="graf graf--p graf-after--p">조금 더 쉽게 생각하면 array.shift()를 하게되면 배열의 가장 첫번째인 0번째 index의 값이 추출되게되고 array 배열의 각 index들은 하나씩 줄어들어 자리를 재배치 한다.</p><figure name="b6c6" id="b6c6" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 480px; max-height: 330px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 68.8%;"></div><img class="graf-image" data-image-id="1*9rHSt4KIYz5rvT_lZPdNcg.png" data-width="480" data-height="330" src="https://cdn-images-1.medium.com/max/800/1*9rHSt4KIYz5rvT_lZPdNcg.png"></div><figcaption class="imageCaption">Queue</figcaption></figure><p name="771a" id="771a" class="graf graf--p graf-after--figure">아래와 같은 변수와 메소드가 필요하다.</p><p name="a0d7" id="a0d7" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">someInstance</code> (type: object)</p><ul class="postList"><li name="cf94" id="cf94" class="graf graf--li graf-after--p">Queue method를 담을 객체</li></ul><p name="7c67" id="7c67" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">storage</code> (type: object)</p><ul class="postList"><li name="1f46" id="1f46" class="graf graf--li graf-after--p">0번째 index에 ‘yonghyun’을 담게되면 storage 객체에는 아래와 같이 담기게 할것이다.</li><li name="58ca" id="58ca" class="graf graf--li graf-after--li">storage = { 0 : ‘yonghyun’ };</li></ul><p name="6c2d" id="6c2d" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">count</code> (type: number)</p><ul class="postList"><li name="e665" id="e665" class="graf graf--li graf-after--p">값을 <code class="markup--code markup--li-code">enqueue()</code> 할때 가장 처음의 값을 delete 하고 count의 길이만큼 앞으로 한칸씩 땡길 때 사용</li><li name="6afe" id="6afe" class="graf graf--li graf-after--li">size값을 알아올 때에도 <code class="markup--code markup--li-code">count</code> 값을 return 하여 얻어 낼 수 있다.</li></ul><p name="3654" id="3654" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">enqueue()</code></p><ul class="postList"><li name="2dca" id="2dca" class="graf graf--li graf-after--p">데이터를 담기 위한 메소드</li></ul><p name="1f9c" id="1f9c" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">dequeue()</code></p><ul class="postList"><li name="e99d" id="e99d" class="graf graf--li graf-after--p">데이터를 빼기 위한 메소드</li></ul><p name="90ee" id="90ee" class="graf graf--p graf-after--li"><code class="markup--code markup--p-code">size()</code></p><ul class="postList"><li name="1df9" id="1df9" class="graf graf--li graf-after--p">담긴 데이터의 length를 구하기 위한 메소드</li></ul><p name="ffa6" id="ffa6" class="graf graf--p graf-after--li">아래처럼 동작 하도록 구현을 하면 될 것 같다.</p><figure name="1167" id="1167" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 653px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 93.30000000000001%;"></div><img class="graf-image" data-image-id="1*GPjL4fPI2J8hBbZLh7DZng.png" data-width="1488" data-height="1388" src="https://cdn-images-1.medium.com/max/800/1*GPjL4fPI2J8hBbZLh7DZng.png"></div><figcaption class="imageCaption">Queue</figcaption></figure><p name="2c24" id="2c24" class="graf graf--p graf-after--figure">위를 구현한 소스코드는 아래와 같다.</p><pre name="e1f6" id="e1f6" class="graf graf--pre graf-after--p">var Queue = function() {<br>  var someInstance = {};</pre><pre name="9cdb" id="9cdb" class="graf graf--pre graf-after--pre">// Use an object with numeric keys to store values<br>  var storage = {};<br>  var count =0;</pre><pre name="654c" id="654c" class="graf graf--pre graf-after--pre">// Implement the methods below</pre><pre name="f7e1" id="f7e1" class="graf graf--pre graf-after--pre">someInstance.enqueue = function(value) {<br>    storage[count]=value;<br>    count ++;<br>  };</pre><pre name="7c96" id="7c96" class="graf graf--pre graf-after--pre graf--trailing">someInstance.dequeue = function() {<br>    if ( count &lt; 1 ){<br>      return ;<br>    }<br>    var popedValue = storage[0];<br>    delete storage[0];<br>    for ( var i = 1 ; i &lt; count ; i ++){<br>      storage[i-1] = storage[i];<br>    }<br>    delete storage[count-1];<br>    count --;<br>    return popedValue;<br>  };<br>  someInstance.size = function() {<br>    return count;<br>  };<br>  return someInstance;<br>};</pre></div></div></section><section name="b7f6" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="b7cd" id="b7cd" class="graf graf--p graf--leading">Stack 과 Queue를 구현을 할 때 여러가지의 방법을 통해서 구현을 했다.</p><p name="9e48" id="9e48" class="graf graf--p graf-after--p">위의 구현 방식은 Functional 방식이며 가장 비효율적인 방식인거 같다.</p><h4 name="2137" id="2137" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Instantiation pattern (인스턴스화 패턴) 은 아래와 같이 4가지 방법이 있다.</strong></h4><h4 name="33af" id="33af" class="graf graf--h4 graf-after--h4">Functional</h4><ul class="postList"><li name="8c15" id="8c15" class="graf graf--li graf-after--h4">함수는 모든 메소드를 담고 있는 객체를 갖고 있다.</li><li name="bc56" id="bc56" class="graf graf--li graf-after--li">생성자를 통해 새로운 Object를 생성 할 때 마다 해당 함수에 있는 모든 내용을 읽는다.</li><li name="572d" id="572d" class="graf graf--li graf-after--li">새로운 객체를 생성할 때 마다 모든 변수와 메소드 들을 읽고 저장해두어야 하므로 효율이 낮다.</li><li name="fbfc" id="fbfc" class="graf graf--li graf-after--li">쉽게 이해하면, <strong class="markup--strong markup--li-strong">“하나의 Function에 모든 것들이 구현되어 있다”</strong></li></ul><h4 name="2540" id="2540" class="graf graf--h4 graf-after--li">Functional-Shared</h4><ul class="postList"><li name="673f" id="673f" class="graf graf--li graf-after--h4">Functional 방식보다는 적은 코드일 때에는 몰라도 코드 길이가 길어지고 새로운 Object 생성이 잦은 곳일 경우에는 Functional-Shared가 더 좋은 구현 방식이 될 수 있다.</li><li name="e8c2" id="e8c2" class="graf graf--li graf-after--li">stack, queue를 구현할때에는 function의 return 값을 전역에 선언되어 있는 메소드 객체를 <code class="markup--code markup--li-code">extend()</code> 하여 구현하였다. (아래는 그 예이다.)</li><li name="ce31" id="ce31" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">_.extend</code> 를 사용하여 객체 두개를 합쳐서 Functional과 비슷해 보이지만 Object의 경우 메모리 값만을 참조 하기 때문에 instance를 생성할 때마다 someInstance에 해당하는 메모리 값을 모두 상속 받는 Functional과는 다르다.</li><li name="8e73" id="8e73" class="graf graf--li graf-after--li">다만 Functional-Shared는 <strong class="markup--strong markup--li-strong">“상속을 받아서 객체의 주소를 참조 하여 사용한다.”</strong> 라는 것이 Functional과의 차이점이다.</li></ul><pre name="4beb" id="4beb" class="graf graf--pre graf-after--li">var <strong class="markup--strong markup--pre-strong">queueMethods</strong> = {};</pre><pre name="5fea" id="5fea" class="graf graf--pre graf-after--pre">queueMethods.enqueue = function(value) {<br>  // enqueue<br>};</pre><pre name="907a" id="907a" class="graf graf--pre graf-after--pre">queueMethods.dequeue = function() {<br>  // dequeue<br>};<br>queueMethods.size = function() {<br>  // size<br>};</pre><pre name="8503" id="8503" class="graf graf--pre graf-after--pre">var Queue = function() {<br>  var <strong class="markup--strong markup--pre-strong">instance</strong> = {<br>    count : 0,<br>    storage : {}<br>  };<br><strong class="markup--strong markup--pre-strong">  return _.extend(instance, queueMethods);</strong><br>};</pre><h4 name="f34a" id="f34a" class="graf graf--h4 graf-after--pre">Prototypal</h4><ul class="postList"><li name="26df" id="26df" class="graf graf--li graf-after--h4">위의 Functional-shared랑은 Prototypal은 차이가 크다.</li><li name="b0b4" id="b0b4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">Object.create(obj)</code> 를 사용하여 외부메소드를 받아 오도록 구현한다.</li><li name="14e0" id="14e0" class="graf graf--li graf-after--li">하지만 <code class="markup--code markup--li-code">Object.create(obj)</code> 는 외부 객체를 연결해 주는 역할만 한다. ( 쉽게 이해하면 가리킨다? 정도로 이해했다. )</li><li name="40fd" id="40fd" class="graf graf--li graf-after--li">그렇게 되면 외부 객체가 아무리 길어도 외부 객체를 가리키는 데이터를 저장할 공간만 있으면 되므로, 매번 새로운 객체를 생성 할 때 마다 새로운 객체는 메소드까지 모두 상속받을 필요가 없다는 것이다.</li><li name="c093" id="c093" class="graf graf--li graf-after--li">그렇다고 메소드를 쓰지 못하는게 아니라 해당 메소드를 사용할 때에는 상속해준 부모의 메서드를 참조 해서 접근한다.</li><li name="48b4" id="48b4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">object.create(obj)</code> 는 <code class="markup--code markup--li-code">obj</code> 를 계속 상속 받기 때문에 아주 약간의 메모리 차지는 하게된다.</li></ul><pre name="18e1" id="18e1" class="graf graf--pre graf-after--li">var <strong class="markup--strong markup--pre-strong">stackMethods</strong> = {};</pre><pre name="694d" id="694d" class="graf graf--pre graf-after--pre">stackMethods.push = function (value) {<br>  // push method<br>};</pre><pre name="ac32" id="ac32" class="graf graf--pre graf-after--pre">stackMethods.pop = function () {<br>  // pop method<br>};</pre><pre name="9351" id="9351" class="graf graf--pre graf-after--pre">stackMethods.size = function () {<br>  // size method <br>};</pre><pre name="fc03" id="fc03" class="graf graf--pre graf-after--pre">var Stack = function() {<br>  <strong class="markup--strong markup--pre-strong">var instance = Object.create(stackMethods);</strong><br>  instance.count = 0;<br>  instance.storage = {};<br>  return instance;<br>};</pre><h4 name="acce" id="acce" class="graf graf--h4 graf-after--pre">Pseudoclassical</h4><ul class="postList"><li name="3da4" id="3da4" class="graf graf--li graf-after--h4">Function을 생성한 후 해당 Function 의 prototype을 정의하여 접근 할수 있도록 한다.</li><li name="bdd7" id="bdd7" class="graf graf--li graf-after--li">Pseudoclassical은 기존에 함수에 정의된 것들을 읽고 가장 나중에 prototype쪽을 읽어 들인다.</li><li name="9700" id="9700" class="graf graf--li graf-after--li">작성 예시는 아래를 확인하자</li></ul><pre name="bfc3" id="bfc3" class="graf graf--pre graf-after--li">var Stack = function() {<br>    this.count = 0;<br>    this.storage = {};<br>};</pre><pre name="a02e" id="a02e" class="graf graf--pre graf-after--pre">Stack.prototype.push = function (value) {<br>  // push method<br>};</pre><pre name="71f2" id="71f2" class="graf graf--pre graf-after--pre">Stack.prototype.pop = function () {<br>  // pop method<br>};</pre><pre name="2dfb" id="2dfb" class="graf graf--pre graf-after--pre">Stack.prototype.size = function () {<br>  // size method<br>};</pre><p name="2cd4" id="2cd4" class="graf graf--p graf-after--pre graf--trailing">이렇게 함으로써 Data Structure 의 기본 “Stack, Queue”를 4가지의 방식으로 나눠서 구현했다.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@lyhlg0201" class="p-author h-card">이용현</a> on <a href="https://medium.com/p/426ccfbdb602"><time class="dt-published" datetime="2017-12-23T06:25:49.051Z">December 23, 2017</time></a>.</p><p><a href="https://medium.com/@lyhlg0201/immersive-sprint-js-stack-queue-426ccfbdb602" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 5, 2020.</p></footer></article></body></html>